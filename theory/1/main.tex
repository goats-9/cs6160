\documentclass[journal,12pt,twocolumn]{IEEEtran}
\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage[breaklinks=true]{hyperref}
\usepackage{tkz-euclide} % loads  TikZ and tkz-base
\usepackage{listings}
\usepackage{color}    
\usepackage{array}    
\usepackage{longtable}
\usepackage{calc}     
\usepackage{multirow} 
\usepackage{hhline}   
\usepackage{ifthen}   
\usepackage{lscape}     
\usepackage{chngcntr}
\DeclareMathOperator*{\Res}{Res}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}
\renewcommand\thetable{\arabic{table}}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible,
literate=
{-}{$\rightarrow{}$}{1},
}
%\lstset{
%language=tex,
%frame=single, 
%breaklines=true
%}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{document}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}
\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}   
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
\providecommand{\system}[1]{\overset{\mathcal{#1}}{ \longleftrightarrow}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\renewcommand{\vec}[1]{\boldsymbol{\mathbf{#1}}}
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}

\vspace{3cm}
\title{CS6160 Assignment 1}
\author{Gautam Singh\\CS21BTECH11018}
\maketitle
\bigskip

\begin{enumerate}
    \item The Vigenere cipher is a cryptosystem with \(\mathcal{M} = \mathcal{C}
    = \mathcal{K} = \cbrak{0,1}^{+}\), and algorithms as follows. Here, we
    assume
        \begin{align}
            m &= m_0m_1\ldots{}m_{N-1} \label{eq:m-def} \\
            k &= k_0k_1\ldots{}k_{M-1} \label{eq:k-def} \\
            c &= c_0c_1\ldots{}c_{N-1} \label{eq:c-def}
        \end{align}
        where \(M\) and \(N\) are some positive integers.
        \begin{enumerate}
            \item \(\textsf{Gen}\) is an algorithm that outputs a key from \(\mathcal{K}\) uniformly at random.
            \item \(\textsf{Enc}: \mathcal{M}\times\mathcal{K}\rightarrow\mathcal{C}\) is defined as
                \begin{equation}
                    \textsf{Enc}\brak{m,k} \triangleq c,\ c_i \triangleq m_i \oplus k_{i\;\brak{\bmod{M}}},\ 0 \le i < N
                    \label{eq:vigenere-enc-def}
                \end{equation}
            \item \(\textsf{Dec}: \mathcal{C}\times\mathcal{K}\rightarrow\mathcal{M}\) is defined as
                \begin{equation}
                    \textsf{Dec}\brak{c,k} \triangleq m,\ m_i \triangleq c_i \oplus k_{i\;\brak{\bmod{M}}},\ 0 \le i < N
                    \label{eq:vigenere-dec-def}
                \end{equation}
        \end{enumerate}

    \item Consider an encryption scheme over the binary alphabet
    \(\Pi\brak{\textsf{Gen},\textsf{Enc},\textsf{Dec}}\), where \(\mathcal{M} =
    \mathcal{C} = \cbrak{0,1}^n\) and \(\mathcal{K} =
    \mathcal{M}\setminus\cbrak{x}\), and
        \begin{align}
            \textsf{Enc}\brak{m,k} &\triangleq m\oplus{}k \label{eq:otp-enc-def} \\
            \textsf{Dec}\brak{c,k} &\triangleq c\oplus{}k \label{eq:otp-dec-def}
        \end{align}
        Clearly, we have
        \begin{equation}
            \pr{C=0^n|M=x} = 0.
            \label{eq:otp-insecure}
        \end{equation}
        We use \eqref{eq:otp-insecure} to create an adversary \(\mathcal{A}\)
        for the indistinguishability experiment. \(\mathcal{A}\) sends message
        texts \(m_0 = x, m_1 = y\) to Alice. If Alice outputs \(0^n\), then
        \(\mathcal{A}\) outputs \(b' = 1\), otherwise \(\mathcal{A}\) outputs
        \(b' = 0\). Here,
        \begin{align}
            &\pr{\textsf{PrivK}_{\mathcal{A},\Pi}^{\textsf{eav}} = 1} \nonumber \\ 
            &= \pr{b' = 0|b = 0}\pr{b=0} \nonumber \\ 
            &+ \pr{b' = 1|b = 1}\pr{b=1} \\
            &= \pr{C \neq 0^n|M = x}\pr{b=0} \nonumber \\ 
            &+ \pr{C = 0^n|M = y}\pr{b=1} \\
            &= \frac{1}{2} + \frac{1}{2\abs{\mathcal{K}}} \le \frac{1}{2} + \epsilon
            \label{eq:K-eps}
        \end{align}
        From \eqref{eq:K-eps}, we see that for an \(\epsilon\)-perfectly secure
        system, we have
        \begin{align}
            \frac{1}{2\abs{\mathcal{K}}} &\le \epsilon \\
            \implies \abs{\mathcal{K}} &\ge \frac{1}{2\epsilon} \\
            \implies 2^n - 1 &\ge \frac{1}{2\epsilon} \\
            \implies n &\ge \log_2\brak{1 + \frac{1}{2\epsilon}}.
            \label{eq:n-cond}
        \end{align}
        From \eqref{eq:n-cond}, it is clear that we can obtain the required
        security by choosing \(n\) sufficiently large.

    \item We describe an adversary \(\mathcal{A}\) that can distinguish between
    \(F\) and a random permutation over \(\cbrak{0,1}^{n\times{}n}\).
    \(\mathcal{A}\) makes the following queries and decisions.
        \begin{enumerate}
            \item Send message \(\vec{m}_1 = \vec{I}\), where \(\vec{I}\)
            denotes the identity matrix. Let the received output be
            \(\vec{c}_1\).
            \item If \(\vec{c}_1\) is not invertible, output 1, else send
            message \(\vec{m}_2 = \vec{c}_1^{-1}\). Let the received output be
            \(\vec{c}_2\).
            \item If \(\vec{c_2} = \vec{I}\), output 0, else output 1.
        \end{enumerate}
        Then, we see that if a random string is used, the probability that
        \(\vec{c}_2 = \vec{I}\) is negligible. If \(F\) is used, then it is
        clear that \(\vec{c_2} = \vec{I}\). Thus,
        \begin{align}
            &\pr{\textsf{PRPExp}\brak{\mathcal{A},\Pi} = 1} \nonumber \\
            &= \frac{1}{2} + \frac{1}{2}\brak{1 - \textrm{negl}\brak{n}} \approx 1.
        \end{align}
        Thus, \(\mathcal{A}\) can distinguish between \(F\) and a random string
        with high probability. Thus, \(F\) is not a PRP.
    
    \item 
    \begin{enumerate}
        \item We have, for \(1 \le i \le t\),
            \begin{equation}
                c_i = v_i + c_{i-1} \bmod{n}.
            \end{equation}
        Thus, inductively,
            \begin{equation}
                c_i = \sum_{j=1}^{i}v_j + c_0 \bmod{n}.
                \label{eq:c-i-closed}
            \end{equation}
        Note that, since \(t < n\) and \(v_i \in \cbrak{0,1}\),
            \begin{equation}
                0 \le  \sum_{i=1}^{t}v_i \le t < n,
                \label{eq:S-lt-n}
            \end{equation}
        and therefore, using \eqref{eq:S-lt-n} and \eqref{eq:c-i-closed},
            \begin{align}
                c_t &= \sum_{i=1}^{t}v_i + c_0 \bmod{n} \\
                \sum_{i=1}^{t}v_i &= c_t - c_0 \bmod{n} = S
            \end{align}
        as required.
            
        \item For \(i = 0\), since \(S = c_t - c_0 \bmod{n}\) and \(S\) is
        fixed, we must have \(c_t = S + c_0 \bmod{n}\). Since \(c_0\) is chosen
        uniformly at random, we have \(n\) uniformly random obtainable pairs
        \(\brak{c_0, c_t}\). Thus,
            \begin{equation}
                \pr{View_0 = \brak{c_0, c_t}} = \frac{1}{n}.
            \end{equation}
        Note that for \(1 \le i \le t\),
            \begin{equation}
                c_i = \brak{\sum_{j=1}^iv_j} + c_0 \bmod{n}.
            \end{equation}
        We must also have \(0 \le c_i - c_0 \bmod{n} \le i\). Hence,
            \begin{align}
                \begin{split}
                &\pr{View_i = \brak{S, c_{i-1}}} \\
                &= \sum_{c_0=0}^{n-1}\pr{View_i = \brak{S, c_{i-1}}, c_0}
                \end{split} \\
                &= \frac{1}{n}\sum_{c_0=0}^{n-1}\pr{View_i = (S, c_{i-1})\ |\ c_0} \\
                &= \frac{1}{n}\sum_{c_0=0}^{n-1}\pr{c_{i-1} = \sum_{k=1}^{i-1}v_k + c_0 \bmod{n}\ \Bigg|\ S, c_0} \\
                &= \frac{1}{n}\sum_{j=0}^{n-1}\frac{\binom{i-1}{j}\binom{t-i+1}{S-j}}{\binom{t}{S}}
            \end{align}
        where we define
            \begin{equation}
                j \triangleq \sum_{k=1}^{i-1}v_k = c_{i-1} - c_0 \bmod{n}.
            \end{equation}
        Since \(0 \le c_0 \le n-1\), we have \(0 \le j \le n-1\). However, we
        know that for some \(0 \le k \le n\),
            \begin{equation}
                \sum_{j=0}^{n}\binom{i}{j}\binom{n-i}{k-j} = \binom{n}{k}.
                \label{eq:bino-binom}
            \end{equation}
        Since \(\max\brak{i-1,t-i+1} \le t \le n - 1 < n\),
            \begin{align}
                \begin{split}
                    &\pr{View_i = \brak{S, c_{i-1}}} \\
                    &= \frac{1}{n\binom{t}{S}}\sum_{j=0}^{t}\binom{i-1}{j}\binom{t-i+1}{S-j}
                \end{split} \\
                &= \frac{1}{n}\frac{\binom{t}{S}}{\binom{t}{S}} = \frac{1}{n}.
            \end{align}
        Thus, the voting protocol is secure with respect to the given definiton.
        
        \item Consider the voters \(i, i+1, i+2\), where \(1 \le i \le t - 2\).
        Voter \(i\) conputes \(c_i\) and passes that on to voter \(i+2\). Now,
        when voter \(i+2\) computes \(c_{i+2}\), we have,
            \begin{equation}
                c_{i+2} = c_i + v_{i+1} + v_{i+2} \bmod{n}
                \label{eq:voter}
            \end{equation}
        Since votes \(i+2\) knows all the terms in \eqref{eq:voter} except the
        requried \(v_{i+1}\), they can use the given information to determine
        it, and thus find the vote of voter \(i+1\).
    \end{enumerate}

    \item Consider the pair of messages \(M_1\) and \(M_2\), where for \(1 \le i
    \le L\),
        \begin{equation}
            M_{1i} = \brak{i - 1},\ M_{2i} = m
        \end{equation}
    where \(m\) is any message block. Then, for all \(i\),
        \begin{align}
            C_{1i} &= \textsf{Enc}\brak{IV, k} \\ 
            C_{2i} &= \textsf{Enc}\brak{IV\oplus{}m\oplus\brak{i-1}, k}.
        \end{align}
    Hence, all ciphertext blocks in \(C_1\) are always equal. We use this as a
    test to distinguish the two messages. We output 1 if all ciphertext blocks
    are equal, and 0 otherwise. Since the probabilities of all ciphertext blocks
    of \(M_2\) can be equal with negligible probability, it follows that we can
    distinguish between these two messages encrypted using this mode of
    operation with high probability.
\end{enumerate}

\end{document}
